Blueprint — Core
Product Requirements Document
Version 2.0
Date: February 17, 2026
Status: Phases 1-3 Complete — Phases 4-5 Planned

---

Executive Summary

Blueprint is an open-source, client-side platform for creating and maintaining living architecture diagrams that stay synchronized with codebases. It runs entirely in the browser — no backend, no accounts, no data leaving the machine.

This document covers the open-source core. A separate cloud product (Blueprint Cloud) will handle collaboration, cloud storage, hosted AI, and team features.

---

Problem Statement

As AI tools handle more code generation, developers spend more time on architecture design, code review, and system comprehension. Current diagram tools fail this workflow:

- Diagrams become obsolete as code evolves
- Static diagrams cannot show both high-level architecture and low-level details
- No link between diagram elements and actual code
- Creating multi-level views requires maintaining separate files manually

Blueprint solves this by generating diagrams from code, linking them to source files, and detecting when they drift.

---

Target Users

1. Software Architect — needs multi-level diagrams, code-to-architecture traceability, anti-pattern detection
2. Tech Lead — needs different detail levels for different audiences, sync status at a glance, onboarding material that stays current
3. Senior Developer / Code Reviewer — needs quick architectural comprehension, code-diagram linking, annotation capabilities

---

Core Features & Requirements

1. Multi-Level Zoom Navigation [COMPLETE]

Unlimited hierarchical diagram navigation from system-level architecture down to individual functions.

- FR1.1: Any diagram element can contain a sub-diagram, indicated by a visual badge
- FR1.2: Double-clicking an element with a sub-diagram opens the detailed view
- FR1.3: Breadcrumb navigation displays current hierarchy path
- FR1.4: Users can skip intermediate levels if no diagrams exist at those levels

Implementation: NodeLink system with blue 3D badges injected into Mermaid SVG via svgParserService. Breadcrumb trail in Preview toolbar. Navigation stack managed by useNavigationHandlers.

2. Diagram Editor [COMPLETE]

Professional Mermaid editor with live preview and AI generation.

- FR2.1: Split-pane editor with live Mermaid rendering
- FR2.2: All Mermaid diagram types supported (flowchart, sequence, class, ER, state, gantt, etc.)
- FR2.3: AI-powered diagram generation from natural language prompts
- FR2.4: Error detection with visual feedback

Implementation: Editor.tsx + Preview.tsx in resizable split pane. AI generation via multi-provider LLM (Gemini, OpenAI, Anthropic).

3. Organization & Export [COMPLETE]

Workspace and folder management with full-fidelity export format.

- FR3.1: Multiple workspaces for different projects
- FR3.2: Nested folder hierarchy within workspaces
- FR3.3: .blueprint export format preserving all metadata (comments, node links, folders, workspace info)
- FR3.4: Legacy import support (.mmd, .mermaid, .txt, .zip)
- FR3.5: Auto-save to localStorage with visual feedback

Implementation: useAppState manages workspaces/folders/diagrams. exportService handles .blueprint format with ID remapping on import.

4. Code Integration [COMPLETE]

Bidirectional linking between diagram elements and source code.

- FR4.1: Connect local repositories via File System Access API (Chromium only)
- FR4.2: Link diagram nodes to specific files and line ranges (CodeLink)
- FR4.3: Green badges on nodes with code links (distinct from blue sub-diagram badges)
- FR4.4: Read-only Monaco Editor panel for viewing linked source code
- FR4.5: Multi-repository support scoped to workspaces
- FR4.6: Automatic codebase scanning with symbol extraction (regex-based, TS/JS/Python)
- FR4.7: Codebase-to-diagram generation (3-level: System Overview, Module Detail, File Detail)

Implementation: fileSystemService wraps File System Access API. codeParserService provides regex-based symbol/import/export extraction. CodePanel uses Monaco in read-only mode. Codebase import generates diagrams in a dedicated folder with NodeLinks for drill-down.

5. Code-Diagram Synchronization [COMPLETE]

Automated detection of divergences between diagrams and code.

- FR5.1: On-demand scan comparing code state with diagram state
- FR5.2: Sync status indicator (green/yellow/red) in Preview toolbar
- FR5.3: Three sync modes: manual, semi-auto, auto
- FR5.4: Typed suggestions: add component, remove component, add relationship, update relationship, mark as obsolete
- FR5.5: Visual diff view via Monaco DiffEditor
- FR5.6: Configurable scan patterns (include/exclude paths, ignore patterns) per repository
- FR5.7: Code scaffolding from diagram structure via LLM

Implementation: codeScannerService handles recursive scanning and divergence detection. ScanResultsPanel groups suggestions by type. DiffViewModal wraps Monaco DiffEditor. scaffoldService generates code via LLM.

6. AI-Assisted Diagram Management [COMPLETE]

Integrated AI for diagram creation, modification, analysis, and code generation.

- FR6.1: AI chat panel for natural language diagram modifications
- FR6.2: Context-aware suggestions based on selected diagram element
- FR6.3: Diagram conversion (e.g., flowchart to sequence diagram)
- FR6.4: Anti-pattern detection with heuristic rules (fan-out, fan-in, god nodes, circular deps, isolated nodes, missing labels)
- FR6.5: Multiple LLM providers: Gemini (SDK), OpenAI (SDK), Anthropic (fetch + CORS proxy)
- FR6.6: Encrypted API key storage (AES-GCM via Web Crypto API + IndexedDB)
- FR6.7: Fallback to heuristic rules when AI is unavailable

Implementation: llmService provides unified multi-provider interface. aiChatService builds prompts. diagramAnalyzerService implements heuristic rules. cryptoStorageService handles AES-GCM encryption. useLLMSettings manages encrypted config with auto-migration from localStorage.

7. CodeGraph [COMPLETE]

Automatic graph generation from a codebase — separate entity from Diagram.

- FR7.1: Hierarchical model: System (D0) > Module (D1) > File (D2) > Symbol (D3)
- FR7.2: ViewLens system for different perspectives (Component, Flow, Domain)
- FR7.3: Smart functional grouping via LLM agent pipeline (2 agents: File Analyst + Architect)
- FR7.4: Heuristic fallback grouper using naming conventions + import affinity
- FR7.5: SHA-256 hash-based sync detection for code drift
- FR7.6: Contextual flow generation with AI-generated sequence diagrams
- FR7.7: Flows are contextual to zoom level (root = end-to-end, module = module-level)
- FR7.8: Progress Log Panel showing pipeline status in real-time
- FR7.9: Force-directed graph visualization with zoom/focus navigation
- FR7.10: Configurable anomaly thresholds and scan patterns

Implementation: codeGraphModelService (CRUD, tree traversal), codeGraphRendererService (graph + lens → Mermaid), codeGraphAgentService (2-agent LLM pipeline), codeGraphHeuristicGrouper (pattern + import affinity), codeGraphFlowService (AI-only flow generation), codeGraphSyncService (SHA-256 change detection). useCodeGraph manages state and pipeline orchestration. CodeGraphPanel and CodeGraphVisualizer handle UI. ProgressLogPanel shows build log.

---

Planned Features (Core)

8. Search & Organization [PLANNED]

- FR8.1: Semantic search across diagrams (by concept, not just title)
- FR8.2: Auto-tagging based on detected patterns
- FR8.3: Search within diagram content (component names, relationships)
- FR8.4: Quick access: Recent, Favorites, Needs Update

9. Version History [PLANNED]

- FR9.1: Timeline view of diagram changes
- FR9.2: Diff between versions
- FR9.3: Restore previous versions

10. Templates & Export [PLANNED]

- FR10.1: Diagram template library (common architectures)
- FR10.2: PDF export with comments and annotations
- FR10.3: HTML export for interactive sharing
- FR10.4: Performance optimization for large diagrams (1000+ nodes)

11. Additional Language Support [PLANNED]

- FR11.1: Extend code parser beyond TS/JS/Python (Java, Go, Rust, C#)
- FR11.2: Framework-aware analysis (React, Spring, Django patterns)

---

Out of Scope (Cloud Product)

The following features are NOT part of the core and will be implemented in Blueprint Cloud:

- Real-time collaboration (Yjs/CRDT, WebSocket server)
- Presence indicators and cursor sharing
- Element-specific comment threads with replies and mentions
- Permission system (view, comment, edit)
- Cloud storage and sync
- Hosted AI (no API key needed)
- Team workspaces and organization management
- User accounts and authentication

---

Technical Architecture

Technology Stack

| Layer               | Technology                                   |
| ------------------- | -------------------------------------------- |
| Framework           | React 19 + TypeScript (strict mode)          |
| Build               | Vite                                         |
| Diagram Rendering   | Mermaid.js v11                               |
| Code Viewer         | Monaco Editor                                |
| Graph Visualization | Canvas 2D (force-directed)                   |
| AI Integration      | Gemini SDK, OpenAI SDK, Anthropic (fetch)    |
| Styling             | Tailwind CSS (CDN)                           |
| Storage             | localStorage + IndexedDB (AES-GCM encrypted) |
| File Access         | File System Access API (Chromium)            |
| Code Parsing        | Regex-based (TS/JS/Python)                   |

Architecture

Client-side only. No backend, no router, no external state library. App.tsx is the root orchestrator, composing state from custom hooks and drilling props to components.

Key patterns:

- State in hooks, logic in services, UI in components
- Props-only components (no context providers)
- Path alias @/\* maps to project root
- Services are pure functions with no React dependency

Data Model

Core entities: Workspace > Folder > Diagram. Diagrams contain Mermaid code, comments, nodeLinks, and codeLinks.

CodeGraph is a separate entity: CodeGraph > GraphNode (hierarchical D0-D3) > GraphRelation. Includes ViewLens for perspective switching, GraphFlow for sequence diagrams, and SyncLock for drift detection.

---

Success Metrics

- Time to first diagram: < 5 minutes
- CodeGraph generation: < 30 seconds for a 50-file project
- Diagram render time: < 500ms for diagrams with < 100 nodes
- Code parsing time: < 5 seconds for typical repositories
- Divergence detection accuracy: > 90% for structural changes
- Build size: production build loads in < 2 seconds

---

Risks & Mitigation

| Risk                                         | Mitigation                                                                      |
| -------------------------------------------- | ------------------------------------------------------------------------------- |
| File System Access API is Chromium-only      | Manual file upload fallback possible; documented as requirement                 |
| Performance with large codebases (100k+ LOC) | Progressive scanning, scope limiting, configurable scan patterns                |
| AI accuracy varies by provider/model         | Heuristic fallbacks for all AI features; clear confidence indicators            |
| Regex parser misses edge cases               | Sufficient for architecture-level analysis; Tree-sitter WASM is a future option |

---

Resolved Questions

- Export format: .blueprint JSON format preserving all metadata. Legacy formats also supported.
- Code parser: Regex-based (not Tree-sitter). Covers TS/JS/Python. Adequate for symbol extraction at architecture level.
- IDE extension: Deferred. Browser-based File System Access API covers the primary use case.

--- End of Document ---
